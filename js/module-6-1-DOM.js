//================== Объектная модель документа =======================

/*Когда мы работаем с браузером, доступный функционал состоит из нескольких модулей, 
так как JavaScript сам по себе не имеет инструментов для работы с браузером.
*/
/*Объектная модель документа (Document Object Model) - независимый от языка интерфейс 
для работы с HTML-документом. Содержит набор свойств и методов позволяющих искать, 
создавать и удалять элементы, реагировать на действия пользователя и многое другое. 
То есть соединяет страницу с языком программирования.
 DOM это отражение HTML-документа - древовидная структура, в которой каждый узел это 
JavaScript-объект со свойствами и методами, представляющий часть HTML-документа. 
Каждый элемент в документе, весь документ в целом, заголовок, ссылка, абзац - это части 
DOM этого документа, поэтому все они могут быть изменены из JavaScript-кода.

  Объектная модель браузера (Browser Object Model) - независимый от языка интерфейс для 
работы с владкой браузера. Содержит набор свойств и методов, позволяющих получить доступ 
непосредственно к текущей вкладке и ряду функций браузера. Включает объект работы с 
историей навигации, местоположением и многое другое.
*/


//================ HTML-документ и DOM ==================

/*Согласно DOM-модели, каждый тег образует отдельный элемент-узел, каждый фрагмент 
текста - текстовый элемент. HTML-документ это иерархическое дерево, в котором у каждого 
элемента (кроме корневого) есть только один родитель, т. е. элемент, внутри которого он 
располагается. Это дерево образуется за счет вложенной структуры тегов и текстовых 
элементов.
*/
/*Чтобы отобразить HTML-документ, браузер сначала преобразовывает его в формат, который 
он понимает - DOM. У движка браузера есть специальный фрагмент кода - HTML-парсер, 
который используется для преобразования HTML в DOM.
 В HTML вложенность определяет отношения родитель-ребенок между элементами. В DOM 
объекты связаны в древовидной структуре данных, фиксируя эти отношения.
 Браузер строит DOM постепенно, как только приходят первые фрагменты кода, он начинает 
парсить HTML, добавляя узлы в древовидную структуру.
*/

/*После того как DOM-дерево построено, в нем можно найти элемент с помощью JavaScript 
и выполнять с ним какие-то действия, так как каждый элемент имеет интерфейс с множеством 
свойств и методов.
*/


//================ DOM-дерево ========================

/*Визуализируем дерево HTML-документа используя сервис генератора DOM-дерева.
*/
// <!DOCTYPE html>
// <html>
//   <head>
//     <title>Document title</title>
//   </head>
//   <body>
//     <h1>Page title</h1>
//     <ul>
//       <li><a href="#">Link 1</a></li>
//       <li><a href="#">Link 2</a></li>
//     </ul>
//   </body>
// </html>
/*В этом дереве выделены два типа узлов.
  • Узлы-элементы (element node) - образуются тегами, естественным образом одни элементы 
вложены в другие. Структура дерева образована исключительно за счет них.
  • Текстовые узлы (text node) - образуются текстом внутри элементов. Текстовый узел 
содержит только строку текста и не может иметь потомков, то есть он всегда на самом 
нижнем уровне иерархии. Пробелы и переносы строк - это тоже текстовые узлы.
*/

/*ИНТЕРЕСНО
Из этого правила есть исключения: пробелы до head игнорируются, а любое содержимое после 
body не создаёт элемент, браузер переносит его в конец body.
*/


//====================== Навигация по DOM ==============================

/*DOM предоставляет широкий спектр возможностей при работе с элементом и его содержимым, 
но для этого на него сначала нужно получить ссылку. Доступ к DOM начинается с объекта 
document, от него можно добраться до любых элементов.
*/

/*ИНТЕРЕСНО
document это часть глобального объекта window, который доступен в скрипте, когда он 
выполняется в браузере. Также как alert, console.log, prompt и многие другие.
*/

/*Элементы DOM-дерева имеют иерархическое отношение друг к другу. Для описания отношений 
используются термины предок (ancestor), потомок (descendant), родитель (parent), ребенок 
(child) и сосед (sibling).
  • Самый верхний элемент называется корневым (root node).
  • Каждый элемент, кроме корневого, имеет только одного родителя.
  • У элемента может быть сколько угодно детей.
  • Соседи - это элементы с общим родителем.
  • Дочерние элементы (дети) - элементы, которые лежат непосредственно внутри текущего 
  (первая вложенность).
  • Потомки – все элементы, которые лежат внутри текущего, вместе с их детьми, детьми 
их детей и так далее. То есть всё поддерево.
*/

/*Для навигации по этой иерархии у элементов есть следующие свойства.
  • elem.parentNode - выберет родителя elem.
  • elem.childNodes - псевдомассив, хранит все дочерние элементы, включая текстовые.
  • elem.children - псевдомассив, хранит только дочерние узлы-элементы, то есть 
соответствующие тегам.
  • elem.firstChild - выберет первый дочерний элемент внутри elem, включая текстовые узлы.
  • elem.firstElementChild - выберет первый дочерний узел-элемент внутри elem.
  • elem.lastChild - выберет последний дочерний элемент внутри elem, включая текстовые узлы.
  • elem.lastElementChild - выберет последний дочерний узел-элемент внутри elem.
  • elem.previousSibling - выберет элемент «слева» от elem (его предыдущего соседа).
  • elem.previousElementSibling - выберет узел-элемент «слева» от elem (его предыдущего соседа).
  • elem.nextSibling - выберет элемент «справа» от elem (его следующего соседа)
  • elem.nextElementSibling - выберет узел-элемент «справа» от elem (его следующего соседа).*/

  /*Открой этот пример в отдельном окне и посмотри логи в консоли разработчика.
  */
// console.log(document);

// const body = document.body;
// console.log(body);

// const list = body.firstElementChild;
// console.log(list);

// const firstListItem = list.firstElementChild;
// console.log(firstListItem);

// const listItems = list.children;
// console.log(listItems);

/*ИНТЕРЕСНО
DOM-коллекции, такие как childNodes и children - псевдомассивы (NodeList), у них нет 
большинства методов массива.
*/









//============== Создание и удаление элементов ===================

/*DOM API позволяет не только выбирать или изменять уже существующие, но и удалять, 
а так же создавать новые элементы, после чего добавлять их в документ.
*/

//============= Создание ==============
// document.createElement(tagName)

/*Создает элемент с именем tagName и возвращает ссылку на него как результат своего выполнения. 
tagName - это строка, указывающая тип создаваемого элемента. Элемент создается в памяти, 
в DOM его еще нет.
*/

// const heading = document.createElement('h1');
// console.log(heading); //<h1></h1>

// heading.textContent = 'This is a heading';
// console.log(heading); // <h1>This is a heading</h1>

// const image = document.createElement('img');
// image.src = 'https://placeimg.com/640/480/nature';
// image.alt = 'Nature';
// console.log(image); // <img src="https://placeimg.com/640/480/nature" alt="Nature" />

//============ Добавление ===========

/*Чтобы созданный элемент был отображен на странице, его необходимо добавить к уже существующему 
элементу в DOM-дереве. Допустим, что добавляем в некий элемент element, для этого есть методы.
 • element.append(el1, el2, ...) - добавляет один или несколько элементов после всех детей элемента element.
 • element.prepend(el1, el2, ...) - добавляет один или несколько элементов перед всеми детьми элемента element.
 • element.after(el1, el2, ...) - добавляет один или несколько элементов после элемента element.
 • element.before(el1, el2, ...) - добавляет один или несколько элементов перед элементом element.
Во всех этих методах, el это элементы или строки, в любом сочетании и количестве. Строки добавляются
как текстовые узлы.
*/

// const list = document.querySelector('.usernames');

// // Adds an item to the end of the list
// const lastItem = document.createElement('li');
// lastItem.textContent = 'Poly';
// list.append(lastItem);

// // Adds an item to the beginning of the list
// const firstItem = document.createElement('li');
// firstItem.textContent = 'Ajax';
// list.prepend(firstItem);

// // Adds a title before the list
// const title = document.createElement('h2');
// title.textContent = 'USERNAME';
// list.before(title);

// // Adds a peragraph after the list
// const text = document.createElement('p');
// text.textContent =
//   "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nostrum tenetur assumenda fugiat maxime, soluta aspernatur quasi nihil in asperiores ad distinctio illo et debitis error iure voluptate numquam maiores nisi. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nostrum tenetur assumenda fugiat maxime, soluta aspernatur quasi nihil in asperiores ad distinctio illo et debitis error iure voluptate numquam maiores nisi!";
// list.after(text);

/*ИНТЕРЕСНО
Если элемент для вставки уже находится в DOM, то он изымается из своего старого места и добавляется 
в новое. Отсюда вытекает правило - один и тот же элемент не может быть одновременно в двух местах.
*/

//============ Удаление ============
// elem.remove();
/*Для того, чтобы удалить элемент используется метод remove(). Он вызывается на самом элементе elem, 
который необходимо удалить
*/

// const text = document.querySelector('.text');
// text.remove()

//============= Оптимизация работы с DOM =============

/*Современные браузеры стараются оптимизировать процесс отрисовки страницы без вмешательства 
разработчика. Тем не менее, изменение DOM-дерева это дорогая операция, поэтому необходимо стараться 
минимизировать количество обращений к DOM.
 • Repaint - происходит, когда изменения затронули стили влияющие на внешний вид элемента, но не на 
геометрию. Например opacity, background-color, visibility и outline. Браузер отрисовывает элемент 
заново, с учётом нового стиля. Также проверяется видимость других элементов, один или более могут 
оказаться скрыты под изменившим внешний вид.

 • Reflow - происходит когда изменения затрагивают содержимое, структуру документа, положение 
элементов. Идет пересчет позиционирования и размеров, что ведет к перерисовке части или всего 
документа. Изменение размера одного родительского контейнера повлияет на всех его детей и предков. 
Имеет значительно большее влияние на производительность, чем repaint.

 Все вышеперечисленные операции блокируют браузер. Страница не может выполнять никакие другие операции
в то время, когда происходит reflow или repaint. Причинами могут быть:

• Манипуляции с DOM (добавление, удаление, изменение, перестановка элементов)
• Изменение содержимого, в т.ч. текста в полях форм
• Расчёт или изменение CSS-свойств
• Добавление и удаление таблиц стилей
• Манипуляции с атрибутом class
• Манипуляции с окном браузера (изменения размеров, прокрутка)
• Активация псевдоклассов (например :hover)
*/


//====================== Свойство innerHTML ======================

/*Еще один способ создать DOM-элементы и поместить их в дерево - это использовать строки с тегами и позволить 
браузеру сделать всю тяжелую работу. У такого подхода есть свои плюсы и минусы.
*/

/*Чтение
Свойство innerHTML хранит содержимое элемента, включая теги, в виде строки. Возвращаемое значение это всегда 
валидный HTML-код.
*/

// const article = document.querySelector('.article');
// console.log(article.innerHTML);

// const title = document.querySelector(".article .title");
// console.log(title.innerHTML);

// const text = document.querySelector(".article .text");
// console.log(text.innerHTML);

// const link = document.querySelector('.article .link');
// console.log(link.innerHTML);


/*Изменение
Свойство innerHTML доступно как для чтения, так и для записи. Если записать в него строку с HTML-тегами, то браузер 
во время парсинга строки превратит их в валидные элементы и добавит в DOM-дерево.
*/

// title.innerHTML = 'New and <span class="accent">improved</span> title';

/*ИНТЕРЕСНО
Если в свойство innerHTML записать пустую строку, то содержимое элемента будет очищено. Это простой и быстрый способ 
удаления всего содержимого.
*/

/*При таком подходе, в отличии от document.createElement(), мы не получаем ссылку на созданный DOM-элемент. 
Это первый шаг на пути к шаблонизации - создания большого количества однотипной разметки с разными данными по 
заранее определённому шаблону. Например, как в списке товаров интернет магазина и т. п.
 Однотипная (шаблонная) разметка создается из массива данных. Приём заключается в переборе этого массива и 
составлении одной строки с HTML тегами, которую потом записываем в innerHTML элемента.
*/

// const technologies = ['HTML', 'CSS', 'JavaScript', 'React', 'Node'];
// const list = document.querySelector('.list');
// console.log(list);

// const markup = technologies
//   .map((technology) => `<li class="list-item">${technology}</li>`)
//   .join('');
// // Check the console, you'll see a single string with HTML tags
// console.log(markup);

// // Adding all the markup in one operation
// list.innerHTML = markup;


/*Добавление
 Изменение elem.innerHTML полностью удалит и пересоздаст всех потомков элемента elem. Если элемент изначально не пустой, 
то будут дополнительные затраты на сериализацию уже существующей разметки, а это плохо.
*/

// const article = document.querySelector('.article');
// console.log(article);

// const htmlString = `<p class="article-text">Nullam quis ante. Vestibulum dapibus nunc ac augue. In consectetuer
// turpis ut velit.</p>
//    <a class="link" href="#">Read more...</a>`;

// Replace += with = operator. See the difference?
// Article title is lost because we overwrite element content.
// article.innerHTML += htmlString;

/*ИНТЕРЕСНО
Используйте свойство elem.innerHTML для добавления только в случае когда элемент elem пустой или если надо полностью 
заменить его содержимое.
*/

//================= Метод insertAdjacentHTML() ======================

/*Современный метод для добавления строки с HTML-тегами до, после или внутрь элемента. Решает проблему innerHTML 
с повторной сериализацией содержимого элемента при добавлении разметки к уже существующей.
*/

// elem.insertAdjacentHTML(position, string);

/*Аргумент position - это строка, позиция относительно элемента elem. Принимает одно из четырёх значений.

inserAdjacentHTML method:
 • "beforebegin" - перед elem
 • "afterbegin" - внутри elem, перед всеми детьми
 • "beforeend" - внутри elem, после всех детей
 • "afterend" - после elem
 */

// const list = document.querySelector('.list');

// const newTechnologies = ['React', 'TypeScript', 'Node.js'];

// const markup = newTechnologies
//   .map((technology) => `<li class="list-item new">${technology}</li>`)
//   .join('');

// list.insertAdjacentHTML('beforeend', markup);
// list.insertAdjacentHTML('beforebegin', '<h2>Popular technologies</h2>')

/*ИНТЕРЕСНО
"beforebegin" и "afterend" работают только в том случае, если elem уже находится в DOM-дереве.
*/


//====================== Подключение скриптов ============================

/*Загрузка и выполнение скрипта указанного в теге <script> без каких-либо атрибутов, блокируют обработку HTML-документа 
и построение DOM. Это проблема.
*/

//<script src="path-to-script.js"></script>

/*Когда анализатор встречает такой тег, обработка HTML-документа приостанавливается и начинается загрузка файла скрипта 
указанного в атрибуте src. После загрузки скрипт выполняется, и только потом возобновляется обработка HTML. 
 Это называется «блокирующий» скрипт.
 Атрибуты defer и async были введены чтобы дать разработчикам возможность лучше контролировать как загружать скрипты и 
когда именно их выполнять.
*/


//================= Атрибут defer ================

//< script defer src = "path-to-script.js" ></script >

/*Атрибут defer указывает браузеру загружать файл скрипта в фоновом режиме, паралельно обработке HTML-документа и 
построению DOM. Скрипт будет выполнен только после того как HTML-документ обработан, а DOM построен. Такие скрипты не 
блокируют построение DOM-дерева и гарантированно выполняются в том порядке, в котором указаны в HTML-документе.
*/

//================= Атрибут async ================

//<script async src="path-to-script.js"></script>

/*Загрузка скрипта с атрибутом async не блокирует построение DOM, но он выполняется сразу после загрузки. Это значит, 
что такие скрипты могут заблокировать построение DOM, и выполняются в произвольном порядке.
*/