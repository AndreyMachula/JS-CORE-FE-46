//=================== Объектно-ориентированное программирование ===================

/*Процедурное программирование - набор не связанных явно функций и переменных для хранения и 
обработки информации. Этот подход прост и прямолинеен и подходит для задач где нет тесно 
связанных сущностей (данных и функций для их обработки).
*/

/*Рассмотрим пример процедурного кода где есть переменные и функция для подсчета результата.*/

// const baseSalary = 30000
// const overtime = 10
// const rate = 20

// const getWage = (baseSalary, overtime, rate) => {
//   return baseSalary + overtime * rate
// }

// console.log(getWage(baseSalary, overtime, rate))

/*Объектно-ориентированное программирование (ООП) - методология, основанная на представлении 
программы в виде совокупности объектов, каждый из которых содержит данные (свойства) и методы 
для взаимодействия с ними.

object-oriented code
Используем ООП, собрав данные в объект employee.
*/

// const employee = {
//   baseSalary: 30000,
//   overtime: 10,
//   rate: 20,
//   getWage() {
//     return this.baseSalary + this.overtime * this.rate
//   }
// }
// console.log(employee.getWage())

/*При таком подходе у метода нету параметров, используются свойства объекта, которые задаются 
при создании объекта и, возможно, так же изменяются другими методами. На выходе получаем 
сущность с простым интерфейсом, что понижает сложность программы.
*/

/*ИНТЕРЕСНО
Идеологически, ООП - это подход к программированию как к моделированию, решающий основную 
задачу - структурирование информации с точки зрения управляемости, что существенно улучшает 
контроль процесса моделирования.
*/

//========================= Сущности ООП ============================

/*Представьте себе, что мы проектируем автомобиль. У него будет двигатель, четыре колеса, 
бензобак и т. д. Автомобиль должен иметь возможность заводиться, набирать и сбавлять скорость. 
Мы знаем как взаимодействует двигатель и колёса, то есть согласно каким законам взаимодействуют 
разные части машины.
*/

//============ Класс ================

/*Мы описываем все запчасти из которых состоит автомобиль, то каким образом эти запчасти 
взаимодействуют между собой и что должен сделать водитель, чтобы машина затормозила, 
включились фары и другое. Результатом нашей работы будет некоторый эскиз (шаблон, схема). 
Мы только что разработали то, что в ООП называется класс.
 Класс - способ описания сущности, определяющий состояние и поведение, зависящее от этого 
состояния, а также правила для взаимодействия с данной сущностью (контракт).
 В нашем случае, класс описывает сущность – автомобиль. Свойствами класса будут двигатель, 
 колеса, фары и т. д. Методами класса будут открыть дверь, завести двигатель, увеличить скорость 
 и т. п.
 */

//============ Экземпляр ================

/*Мы спроектировали чертежи и машины, разработанные по ним, сходят с конвейера. Каждая из них
точно повторяет чертеж, все системы взаимодействуют именно так, как мы спроектировали, но каждая 
машина уникальна. Они все имеют номер кузова и двигателя, но все номера разные, автомобили 
различаются цветом, отделкой салона. Эти автомобили являются экземплярами класса.
 Экземпляр (объект) - это отдельный представитель класса, имеющий конкретное состояние и поведение, 
полностью определяемое классом. Это то, что создано по чертежу, то есть по описанию из класса.
 Говоря простым языком, объект имеет конкретные значения свойств и методы, работающие с этими 
 свойствами на основе правил, заданных в классе. В данном примере, если класс - это некоторый 
 абстрактный автомобиль на чертеже, то объект - это конкретный автомобиль, стоящий у нас под окнами.
 */

 //============ Интерфейс ================

 /*Когда мы подходим к автомату с кофе или садимся за руль автомобиля, существует некоторый набор
элементов управления, с которыми мы можем взаимодействовать.
 Интерфейс - это набор свойств и методов класса, доступных для использования при работе с экземпляром.
 По сути, интерфейс описывает класс, чётко определяя все возможные действия над ним. Хороший пример 
 интерфейса - приборная панель автомобиля, которая позволяет вызвать такие методы как увеличение 
скорости, торможение, поворот, переключение передач, включение фар и т. п.
При описании интерфейса класса очень важно соблюсти баланс между гибкостью и простотой. Класс с 
простым интерфейсом будет легко использовать, но будут существовать задачи, которые с помощью 
него решить будет не под силу.
 Если интерфейс будет гибким, то скорее всего, он будет состоять из достаточно сложных методов 
с большим количеством параметров, которые будут позволять делать очень многое, но его использование 
будет сопряжено с большими сложностями и риском совершить ошибку, что-то перепутав.
*/


//=================== Прототипное наследование ===================

/*ООП в JavaScript построено на прототипном наследовании. Объекты можно организовать в цепочки так, 
чтобы свойство не найденное в одном объекте, автоматически искалось бы в другом. Связующим звеном 
выступает специальное скрытое свойство [[Prototype]], которое в консоли браузера отображается 
как __proto__.
*/

 //============ Прототип объекта ================

/*Метод Object.create(obj) создаёт и возвращает новый объект, связывая его с объектом obj.
*/

// const animal = {
//   legs: 4,
// }
// const dog = Object.create(animal)
// dog.name = 'Mango'

// console.log(dog) // { name: 'Манго', __proto__: animal }
// console.log(animal.isPrototypeOf(dog)) // true

/*Объект, на который указывает ссылка в __proto__, называется прототипом. В нашем примере объект animal это прототип 
для объекта dog. Метод isPrototypeOf() проверяет является ли объект animal прототипом для dog и возвращает 
true или false.*/

// console.log(dog.hasOwnProperty("name")) // true
// console.log(dog.name) // 'Mango'

// console.log(dog.hasOwnProperty("legs")) // false
// console.log(dog.legs) // 4

/*Обращение dog.name работает очевидным образом - возвращает собственное свойство name объекта dog. 
При обращении к dog.legs интерпретатор ищет свойство legs в объекте dog, не находит и продолжает поиск 
в объекте по ссылке из dog.__proto__, то есть, в данном случае, в объекте animal - его прототипе.
 То есть прототип - это резервное хранилище свойств и методов объекта, автоматически используемое 
при их поиске. У объекта, который выступает прототипом может также быть свой прототип, у того свой, и так далее.
 Поиск свойства выполняется до первого совпадения. Интерпретатор ищет свойство по имени в объекте, если не находит, 
то обращается к свойству __proto__, т. е. переходит по ссылке к объекту-прототипу, а затем и прототипу прототипа. 
Если интерпретатор доберется до конца цепочки и не найдет свойства с таким именем, то вернёт undefined.
*/

/*ИНТЕРЕСНО
В спецификации свойство __proto__ обозначено как [[Prototype]]. Двойные квадратные скобки здесь важны, они 
указывают на то, что это внутреннее, служебное свойство.
*/


 //============ Метод hasOwnProperty() ================

 /*После того как мы узнали о том, как происходит поиск свойств объекта, должно стать понятно, почему цикл for...in
 не делает различия между свойствами объекта и его прототипа.
 */

// const animal = {
//    eats: true,
// }
// const dog = Object.create(animal)
// dog.barks = true
 
// for (const key in dog) {
//   console.log(key) // barks, eats
// }

/*Именно поэтому мы используем метод obj.hasOwnProperty(prop), который возвращает true, если свойство 
prop принадлежит самому объекту obj, а не его прототипу, иначе false.
*/

// const animal = {
//   eats: true,
// }
// const dog = Object.create(animal)
// dog.barks = true

// for (const key in dog) {
//   if (!dog.hasOwnProperty(key)) continue

//   console.log(key) // barks
// }

/*Метод Object.keys(obj) вернет массив только собственных ключей объекта obj, поэтому на практике 
используют именно его, а не for...in.
*/

// const animal = {
//   eats: true,
// };
// const dog = Object.create(animal);
// dog.barks = true;

// const dogKeys = Object.keys(dog);

// console.log(dogKeys); // ['barks']



//================= EXAMPLE ================
//==================== 1 ===================

/*Измени код так, чтобы объект parent стал прототипом для объекта в переменной сhild.
*/

// const parent = {
//   name: "Stacey",
//   surname: "Moore",
//   age: 54,
//   heritage: "Irish",
// }

// const child = Object.create(parent)

// child.name = "Jason"
// child.age = 27

// console.log(child)

//==================== 2 ===================

/*Измени код, построив цепочку прототипов так, чтобы объект ancestor был прототипом 
для parent, а тот в свою очередь был прототипом для child.
*/

// const ancestor = {
//   name: "Paul",
//   age: 83,
//   surname: "Dawson",
//   heritage: "Irish",
// };
// // Change code below this line

// const parent = Object.create(ancestor);
// parent.name = "Stacey";
// parent.surname = "Moore";
// parent.age = 54;

// const child = Object.create(parent);
// child.name = "Jason";
// child.age = 27;

// console.log(parent)
// console.log(child)


//=================== Классы ===================

/*Синтаксис литерала объекта позволяет создать один объект. Но часто нужно создать много однотипных объектов 
с одинаковым набором свойств, но разными значениями и методами для взаимодействия с ними. Всё это нужно 
сделать динамичекски, во время выполнения программы. Для этого используют классы - специальный синтаксис 
объявления функции для создания объектов.
*/

//=================== Объявление класса ===================

/*Объявление класса начинается с ключевого слова class, после которого идёт имя класса и фигурные 
скобки - его тело. Классы принято называть с большой буквы, а в самом названии отражать тип создаваемого 
объекта (существительное).
*/

// class User {
//   // Тело класса
// }

// const mango = new User()
// console.log(mango) // User {}

// const poly = new User()
// console.log(poly) // User {}

/*Результат вызова new User() это объект, который называется экземпляр класса, потому что содержит данные и 
поведение, описываемые классом.
*/

/*ИНТЕРЕСНО
Как строить класс, зависит от того, что вам нужно. В нашем случае, класс представляет собой пользователя, 
поэтому мы добавим туда поля для имени и почты.
*/


//=================== Конструктор класса ===================

/*Для инициализации экземпляра в классе есть метод constructor. Если он не объявлен, создаётся конструктор 
по умолчанию - пустая функция, которая не изменяет экземпляр.
*/

// class User {
//   // Синтаксис объявления метода класса
//   constructor(name, email) {
//     // Инициализация свойств экземпляра
//     this.name = name
//     this.email = email
//   }
// }

// const mango = new User("Манго", "mango@mail.com")
// console.log(mango) // { name: 'Манго', email: 'mango@mail.com' }

// const poly = new User("Поли", "poly@mail.com")
// console.log(poly) // { name: 'Поли', email: 'poly@mail.com' }

/*Вызов класса с оператором new приводит к созданию нового объекта и вызову конструктора в контексте этого объекта. 
 То есть this внутри конструктора будет ссылаться на новосозданный объект. Это позволяет добавлять каждому объекту 
свойства с одинаковыми именами, но разными значениями.
 Свойства name и email называются публичные свойства, потому что они будут собственными свойствами объекта-экземпляра 
и к ним можно будет получить доступ обратившись через точку.*/

//============== EXAMPLE ================
//================= 1 ===================

/*Добавь классу Car метод constructor который принимает три параметра:
  • brand - марка автомобиля.
  • model - модель автомобиля.
  • price - цена автомобиля.
Класс Car должен создавать объект с одноимёнными свойствами brand, model и price, значениями которых должны быть 
переданные аргументы во время её вызова с оператором new.
*/

// class Car {
//   constructor(brand, model, price) {
//     this.brand = brand
//     this.model = model
//     this.price = price
//   }
// }

// const audi = new Car("Audi", "Q3", 36000)
// console.log(audi)

// const bmw = new Car("BMW", "X5", 58900)
// console.log(bmw)

// const nissan = new Car("Nissan","Murano", 31700)
// console.log(nissan)


//=================== Объект параметров ===================

/*Класс может принимать большое количество входных данных для свойств будущего объекта. Поэтому к ним также можно 
применить паттерн «Объект параметров, передавая один объект с логично именованными свойствами, вместо несвязанного 
набора аргументов.
*/

// class User {
//   // Деструктуризируем объект
//   constructor({ name, email }) {
//     this.name = name;
//     this.email = email;
//   }
// }

// const mango = new User({
//   name: "Манго",
//   email: "mango@mail.com",
// });
// console.log(mango); // { name: "Манго", email: "mango@mail.com" }

// const poly = new User({
//   name: "Поли",
//   email: "poly@mail.com",
// });
// console.log(poly); // { name: "Поли", email: "poly@mail.com" }

//============== EXAMPLE ================
//================= 1 ===================

/*Выполни рефакторинг класса Car так, чтобы он принимал один параметр - объект со свойсвами brand, model и price. 
Деструктуризируй объект в сигнатуре (подписи) конструктора.
*/

//  class Car {
//    constructor({ brand, model, price }) {
//     this.brand = brand
//     this.model = model
//     this.price = price
//   }
// }

// const audi = new Car({
//   brand: "Audi",
//   model: "Q3",
//   price: 36000,
// })
// console.log(audi)

// const bmw = new Car({
//   brand: "BMW",
//   model: "X5",
//   price: 58900,
// })
// console.log(bmw)

// const nissan = new Car({
//   brand: "Nissan",
//   model: "Murano",
//   price: 31700,
// })
// console.log(nissan)


//=================== Методы класса ===================

/*Для работы со свойствами будущего экземпляра используются методы класса - функции которые будут доступны 
экземпляру в его прототипе.
*/

// class User {
//   constructor({ name, email }) {
//     this.name = name;
//     this.email = email;
//   }

//   // Метод getEmail
//   getEmail() {
//     return this.email;
//   }

//   // Метод changeEmail
//   changeEmail(newEmail) {
//     this.email = newEmail;
//   }
// }

// const mango = new User({
//   name: 'Mango',
//   email: '1234@gmail.com',
// })

// console.log(mango)


//============== EXAMPLE ================
//================= 1 ===================

/*Добавь классу Car два метода.
  • getPrice() - возвращает значение свойства price из объекта который его будет вызывать.
  • changePrice(newPrice) - обновляет значение свойства price у объекта который его будет вызывать на newPrice.
*/

// class Car {
//   constructor({ brand, model, price }) {
//     this.brand = brand;
//     this.model = model;
//     this.price = price;
//   }

//   getPrice() {
//     return this.price
//   }

//   changePrice(newPrice) {
//     this.price = newPrice
//   }
// }

//  const nissan = new Car({
//   brand: "Nissan",
//   model: "Murano",
//   price: 31700,
// })
// console.log(Car.prototype.hasOwnProperty('getPrice'))


//================= 2 ===================

/*Напиши класс Storage, который будет создавать объекты для управления складом товаров. 
Класс ожидает только один аргумент - начальный массив товаров, который записывается на 
создаваемый объект в свойство items.
 Объяви следующие методы класса:
  • getItems() - возвращает массив текущих товаров в свойстве items объекта который 
вызывает этот метод.
  • addItem(newItem) - принимает новый товар newItem и добавляет его в массив товаров 
в свойстве items объекта который вызывает этот метод.
  • removeItem(itemToRemove) - принимает товар itemToRemove и удаляет его из массива 
товаров в свойстве items объекта который вызывает этот метод.
Под комментарием мы добавили инициализацию экземпляра и вызовы методов в той последовательности, 
в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.
*/

// class Storage {
//   constructor(items) {
//     this.items = items
//   }
  
//   getItems() {
//     return this.items
//   }

//   addItem(newItem) {
//     this.items.push(newItem)
//   }

//   removeItem(itemToRemove) {
//     this.items = this.items.filter(item => item !== itemToRemove)
//   }
// }

// const storage = new Storage(["Nanitoids", "Prolonger", "Antigravitator"])
// console.log(storage.getItems()) // ["Nanitoids", "Prolonger", "Antigravitator"]

// storage.addItem("Droid")
// console.log(storage.getItems()) // ["Nanitoids", "Prolonger", "Antigravitator", "Droid"]

// storage.removeItem("Prolonger");
// console.log(storage.getItems()); // ["Nanitoids", "Antigravitator", "Droid"]

// const courseTopic = 'JavaScript essentials'


//================= 3 ===================

/*Напиши класс StringBuilder, который принимает один параметр initialValue - произвольную 
строку, которая записывается на создаваемый объект в свойство value.
 Объяви следующие методы класса:
  • getValue() - возвращает текущее значение свойства value.
  • padEnd(str) - получает парметр str (строку) и добавляет её в конец значения свойства 
  value объекта который вызывает этот метод.
  • padStart(str) - получает парметр str (строку) и добавляет её в начало значения свойства 
  value объекта который вызывает этот метод.
  • padBoth(str) - получает парметр str (строку) и добавляет её в начало и в конец значения 
  свойства value объекта который вызывает этот метод.
 Под комментарием мы добавили инициализацию экземпляра и вызовы методов в той последовательности, 
 в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.
 */

// class StringBuilder {
//   constructor(initialValue) {
//     this.value = initialValue
//   }

//   getValue() {
//      return this.value
//   }

//   padEnd(str) {
//     this.value += str
//   }

//   padStart(str) {
//     this.value = str + this.value
//   }

//   padBoth(str) {
//     this.value = str + this.value + str
//   }
  
// }

// const builder = new StringBuilder(".");
// console.log(builder.getValue()); // "."

// builder.padStart("^");
// console.log(builder.getValue()); // "^."

// builder.padEnd("^");
// console.log(builder.getValue()); // "^.^"

// builder.padBoth("=");
// console.log(builder.getValue()); // "=^.^="



//=================== Приватные свойства ===================

/*Инкапсуляция - это концепция позволяющая скрыть внутренние детали класса. Пользователь 
класса должен получать доступ только к публичному интерфейсу - набору публичных свойств 
и методов класса.
 В классах инкапсуляция реализуется приватными свойствами, доступ к которым можно получить 
только внутри класса.
 Допустим, почта пользователя должна быть недоступна для прямого изменения из вне, то есть 
приватна. Добавляя к имени свойства символ # мы делаем его приватным. Объявление приватного 
свойства до инциализации в конструкторе - обязательно!
*/

// class User {
//   // Необязательное объявление публичных свойств
//   name;
//   // Обязательное объявление приватных свойств
//   #email;

//   constructor({ name, email }) {
//     this.name = name;
//     this.#email = email;
//   }

//   getEmail() {
//     return this.#email;
//   }

//   changeEmail(newEmail) {
//     this.#email = newEmail;
//   }
// }

// const mango = new User({
//   name: "Манго",
//   email: "mango@mail.com",
// });
// mango.changeEmail("mango@supermail.com");
// console.log(mango.getEmail()); // mango@supermail.com
// console.log(mango.#email); // Будет ошибка, это приватное свойство

/*Методы класса также могут быть приватными, то есть доступны только в теле класса. 
Для этого перед их именем необходимо поставить символ #.
*/


//============== EXAMPLE ================
//================= 1 ===================

/*Выполни рефакторинг класса Car так, чтобы свойство brand было приватным и добавь два 
метода для публичного интерфейса, для чтения и изменения этого свойства.
  • getBrand() - возвращает значение приватного свойства brand.
  • changeBrand(newBrand) - изменяет значение приватного свойства brand на newBrand.
*/
// class Car {
//   #brand;
//   constructor({ brand, model, price }) {
//     this.#brand = brand;
//     this.model = model;
//     this.price = price;
//   }

//   getBrand() {
//     return this.#brand
//   }

//   changeBrand(newBrand) {
//     this.#brand = newBrand
//   }
// }

// const audi = new Car({
//   brand: "Audi",
//   model: "Q3",
//   price: 36000,
// })

// console.log(audi)

//================= 2 ===================

/*Выполни рефакторинг класса Storage, сделав свойство items приватным.
Под комментарием мы добавили инициализацию экземпляра и вызовы методов в той 
последовательности, в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.
*/

// class Storage {
//   #items;
  
//   constructor(items) {
//     this.#items = items;
//   }

//   getItems() {
//     return this.#items;
//   }

//   addItem(newItem) {
//     this.#items.push(newItem);
//   }

//   removeItem(itemToRemove) {
//     this.#items = this.#items.filter(item => item !== itemToRemove);
//   }

  
// }

// const storage = new Storage([
//   "Nanitoids",
//   "Prolonger",
//   "Antigravitator",
// ])
// console.log(storage.getItems());

// storage.addItem("Droid")
// console.log(storage.getItems())

// storage.removeItem("Prolonger")
// console.log(storage.getItems())


//================= 3 ===================

/*Выполни рефакторинг класса StringBuilder, сделав свойство value приватным.
Под комментарием мы добавили инициализацию экземпляра и вызовы методов в той 
последовательности, в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.
*/

// class StringBuilder {
//   #value;
//   constructor(initialValue) {
//     this.#value = initialValue;
//   }

//   getValue() {
//     return this.#value;
//   }

//   padEnd(str) {
//     this.#value += str;
//   }

//   padStart(str) {
//     this.#value = str + this.#value;
//   }

//   padBoth(str) {
//     this.padStart(str);
//     this.padEnd(str);
//   }
// }

// const builder = new StringBuilder(".");
// console.log(builder.getValue()); // "."
// builder.padStart("^");
// console.log(builder.getValue()); // "^."
// builder.padEnd("^");
// console.log(builder.getValue()); // "^.^"
// builder.padBoth("=");
// console.log(builder.getValue()); // "=^.^="


//================= Геттеры и сеттеры ===================

/*Геттеры и сеттеры - это более краткий синтаксис объявления методов для взаимодействия 
со свойствами. Геттер и сеттер имитируют обычное публичное свойство класса, но позволяют 
изменять другие свойства более удобным способом. Геттер выполняется при попытке получить 
значение свойства, а сеттер - при попытке его изменить.
 Геттеры и сеттеры хорошо использовать для простых операций чтения и изменения значения свойств, 
особенно приватных, как их публичный интерфейс. Для работы со свойством которое хранит массив или 
объект они не подойдут.
*/

// class User {
//   #email;

//   constructor({ name, email }) {
//     this.name = name
//     this.#email = email
//   }

//   // Геттер email
//   get email() {
//     return this.#email
//   }

//   // Сеттер email
//   set email(newEmail) {
//     this.#email = newEmail
//   }

  
// }

/*Мы объявили геттер и сеттер email поставив перед именем свойства ключевые слова get и set. 
 Внутри этих методов мы или возвращаем значение приватного свойства #email или изменяем его значение. 
Геттер и сеттер идут впаре и должны называться одинаково.
*/

// const mango = new User({
//   name: 'Mango',
//   email: 'mango@mail.com'
// })
// console.log(mango.email)

// mango.email = 'mango@superemail.com'
// console.log(mango.email)


/*При обращении к mango.email вызызвается геттер get email() {...} и выполняется его код. 
При попытке записи mango.email = "mango@supermail.com" вызывается сеттер set email(newEmail) {...} 
и строка "mango@supermail.com" будет значением параметра newEmail.
 Плюс в том, что это методы, а значит при записи можно выполнить дополнительный код, например с 
какими-то проверками, в отличии от выполнениях этой же операции напрямую со свойством.
*/

// set email(newEmail) {
//   if (newEmail === '') {
//     console.error("Ошибка! Почта не может быть пустой строкой!")

//     return
//   }
// }


//============== EXAMPLE ================
//================= 1 ===================

/*Выполни рефакторинг класса Car. Сделай свойства model и price приватными, также как #brand. 
Стандартизируй публичный интерфейс класса заменив уже объявленные методы на геттеры и сеттеры 
brand, model и price для взаимодействия с приватными свойствами.
*/

// class Car {
//   #brand;
//   #model;
//   #price;


//   constructor({ brand, model, price }) {
//     this.#brand = brand
//     this.#model = model
//     this.#price = price
//   }

//   get brand() {
//     return this.#brand
//   }

//   set brand(newBrand) {
//     this.#brand = newBrand
//   }

//   get model() {
//     return this.#model
//   }

//   set model(newModel) {
//     this.#model = newModel
//   }

//   get price() {
//     return this.#price
//   }

//   set price(newPrice) {
//     this.#price = newPrice
//   }
// }


//================= Статические свойства ===================

/*Кроме публичных и приватных свойств будущего экземпляра, в классе можно объявить его собственные 
свойства, доступные только классу, но не его экземплярам - статические свойства (static). Они 
полезны для хранения информации относящейся к самому классу.
 Добавим классу пользователя приватное свойство role - его роль, определяющую набор прав, например 
администратор, редактор, просто пользователь и т п. Возможные роли пользователей будем хранить 
как статическое свойство Roles - объект со свойствами.
 Статические свойства объявляются в теле класса. Перед именем свойства добавляется ключевое 
слово static.
*/

// class User {
//   // Объявление и инициализация статического свойства
//   static Roles = {
//     ADMIN: 'admin',
//     EDITOR: 'editor',
//   }
//   #email;
//   #role;

//   constructor({ email, role }) {
//     this.#email = email
//     this.#role = role
//   }

//   get role() {
//     return this.#role
//   }

//   set role(newRole) {
//     this.#role = newRole
//   }
// }

// const mango = new User({
//   email: 'mango@mail.com',
//   role: User.Roles.ADMIN,
// })

// console.log(mango.Roles) // undefined
// console.log(User.Roles) // {ADMIN: 'admin', EDITOR: 'editor'}

// console.log(mango.role) // admin
// mango.role = User.Roles.EDITOR
// console.log(mango.role) // editor

/*Статические свойства также могут быть приватные, то есть доступные только внутри класса. 
Для этого имя совйства должно начинаться с символа #, также как приватные свойства. 
Обращение к приватному статическому свойству вне тела класса вызовет ошибку.
*/


//================= Статические методы ===================

/*В классе можно объявить не только методы будущего экземпляра, но и методы доступные только 
классу - статические методы, которые могут быть как публичные так и приватные. Синтаксис 
объявления аналогичен статическим свойствам, за исключением того что значением будет метод.
*/

// class User {
//   static #takenEmails = []

//   static isEmailTaken(email) {
//     return User.#takenEmails.includes(email)
//   }

//   #email;

//   constructor({email}) {
//     this.#email = email
//     User.#takenEmails.push(email)
//   }
// }

// const mango = new User({ email: 'mango@mail.com' })

// console.log(User.isEmailTaken('poly@mail.com'))
// console.log(User.isEmailTaken('mango@mail.com'))

/*Особенность статических методов в том, что во время их вызова ключевое слово this ссылается 
на сам класс. Это значит что статический метод может получить доступ к статическим свойствам 
класса, но не к свойствам экземпляра. Логично, потому что статические методы вызывает сам класс, 
а не его экземпляры.
*/


//================= Наследование классов ===================

/*Ключевое слово extends позволяет реализовать наследование классов, когда один класс 
(дочерний, производный) наследует свойства и методы другого класса (родителя).'
*/

// class Child extends Parent {
//   // ...
// }

/*В выражении class Child extends Parent дочерний класс Child наследует (расширяет) от родительского 
класса Parent.
 Это означает, что мы можем объявить базовый класс, который хранит общие характеристики и методы для 
группы производных классов, которые наследуют свойства и методы родителя, но также добавляют свои 
уникальные.
 Например, в приложении есть пользователи разных ролей - администратор, писатель статей, контент 
менеджер и т. п. У каждого типа пользователя есть набор общих характеристик, например почта и пароль, 
но также есть и уникальные.
 Сделав независимые классы для каждого типа пользователя мы получим дублирование общих свойств и 
методов, и при необходимости изменить например название свойства, придётся проходить по всем классам, 
это неудобно и трудозатратно.
 Вместо этого можно сделать общий класс User, который будет хранить набор общих свойств и методов, 
после чего сделать классы для каждого типа пользователя которые наследуют этот набор от класса User. 
При необходимости изменить что-то общее, достаточно будет поменять только код класса User.
*/

// class User {
//   constructor(email) {
//     this.email = email
//   }

//   get email() {
//     return this.email
//   }

//   set email(newEmail) {
//     this.email = newEmail
//   }
// }

// class ContentEditor extends User {
//   // Тело класса ContentEditor
// }

// const editor = new ContentEditor("mango@mail.com")
// console.log(editor) // { email: "mango@mail.com" }
// console.log(editor.email) // "mango@mail.com"

/*Класс ContentEditor наследует от класса User его конструктор, геттер и сеттер email, а также 
одноимённое публичное свойство. Важно помнить что приватные свойства и методы класса-родителя не 
наследуются классом-ребёнком.
*/


