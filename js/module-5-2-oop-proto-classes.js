//=================== Объектно-ориентированное программирование ===================

/*Процедурное программирование - набор не связанных явно функций и переменных для хранения и 
обработки информации. Этот подход прост и прямолинеен и подходит для задач где нет тесно 
связанных сущностей (данных и функций для их обработки).
*/

/*Рассмотрим пример процедурного кода где есть переменные и функция для подсчета результата.*/

// const baseSalary = 30000
// const overtime = 10
// const rate = 20

// const getWage = (baseSalary, overtime, rate) => {
//   return baseSalary + overtime * rate
// }

// console.log(getWage(baseSalary, overtime, rate))

/*Объектно-ориентированное программирование (ООП) - методология, основанная на представлении 
программы в виде совокупности объектов, каждый из которых содержит данные (свойства) и методы 
для взаимодействия с ними.

object-oriented code
Используем ООП, собрав данные в объект employee.
*/

// const employee = {
//   baseSalary: 30000,
//   overtime: 10,
//   rate: 20,
//   getWage() {
//     return this.baseSalary + this.overtime * this.rate
//   }
// }
// console.log(employee.getWage())

/*При таком подходе у метода нету параметров, используются свойства объекта, которые задаются 
при создании объекта и, возможно, так же изменяются другими методами. На выходе получаем 
сущность с простым интерфейсом, что понижает сложность программы.
*/

/*ИНТЕРЕСНО
Идеологически, ООП - это подход к программированию как к моделированию, решающий основную 
задачу - структурирование информации с точки зрения управляемости, что существенно улучшает 
контроль процесса моделирования.
*/

//========================= Сущности ООП ============================

/*Представьте себе, что мы проектируем автомобиль. У него будет двигатель, четыре колеса, 
бензобак и т. д. Автомобиль должен иметь возможность заводиться, набирать и сбавлять скорость. 
Мы знаем как взаимодействует двигатель и колёса, то есть согласно каким законам взаимодействуют 
разные части машины.
*/

//============ Класс ================

/*Мы описываем все запчасти из которых состоит автомобиль, то каким образом эти запчасти 
взаимодействуют между собой и что должен сделать водитель, чтобы машина затормозила, 
включились фары и другое. Результатом нашей работы будет некоторый эскиз (шаблон, схема). 
Мы только что разработали то, что в ООП называется класс.
 Класс - способ описания сущности, определяющий состояние и поведение, зависящее от этого 
состояния, а также правила для взаимодействия с данной сущностью (контракт).
 В нашем случае, класс описывает сущность – автомобиль. Свойствами класса будут двигатель, 
 колеса, фары и т. д. Методами класса будут открыть дверь, завести двигатель, увеличить скорость 
 и т. п.
 */

//============ Экземпляр ================

/*Мы спроектировали чертежи и машины, разработанные по ним, сходят с конвейера. Каждая из них
точно повторяет чертеж, все системы взаимодействуют именно так, как мы спроектировали, но каждая 
машина уникальна. Они все имеют номер кузова и двигателя, но все номера разные, автомобили 
различаются цветом, отделкой салона. Эти автомобили являются экземплярами класса.
 Экземпляр (объект) - это отдельный представитель класса, имеющий конкретное состояние и поведение, 
полностью определяемое классом. Это то, что создано по чертежу, то есть по описанию из класса.
 Говоря простым языком, объект имеет конкретные значения свойств и методы, работающие с этими 
 свойствами на основе правил, заданных в классе. В данном примере, если класс - это некоторый 
 абстрактный автомобиль на чертеже, то объект - это конкретный автомобиль, стоящий у нас под окнами.
 */

 //============ Интерфейс ================

 /*Когда мы подходим к автомату с кофе или садимся за руль автомобиля, существует некоторый набор
элементов управления, с которыми мы можем взаимодействовать.
 Интерфейс - это набор свойств и методов класса, доступных для использования при работе с экземпляром.
 По сути, интерфейс описывает класс, чётко определяя все возможные действия над ним. Хороший пример 
 интерфейса - приборная панель автомобиля, которая позволяет вызвать такие методы как увеличение 
скорости, торможение, поворот, переключение передач, включение фар и т. п.
При описании интерфейса класса очень важно соблюсти баланс между гибкостью и простотой. Класс с 
простым интерфейсом будет легко использовать, но будут существовать задачи, которые с помощью 
него решить будет не под силу.
 Если интерфейс будет гибким, то скорее всего, он будет состоять из достаточно сложных методов 
с большим количеством параметров, которые будут позволять делать очень многое, но его использование 
будет сопряжено с большими сложностями и риском совершить ошибку, что-то перепутав.
*/


//=================== Прототипное наследование ===================

/*ООП в JavaScript построено на прототипном наследовании. Объекты можно организовать в цепочки так, 
чтобы свойство не найденное в одном объекте, автоматически искалось бы в другом. Связующим звеном 
выступает специальное скрытое свойство [[Prototype]], которое в консоли браузера отображается 
как __proto__.
*/

 //============ Прототип объекта ================

/*Метод Object.create(obj) создаёт и возвращает новый объект, связывая его с объектом obj.
*/

// const animal = {
//   legs: 4,
// }
// const dog = Object.create(animal)
// dog.name = 'Mango'

// console.log(dog) // { name: 'Манго', __proto__: animal }
// console.log(animal.isPrototypeOf(dog)) // true

/*Объект, на который указывает ссылка в __proto__, называется прототипом. В нашем примере объект animal это прототип 
для объекта dog. Метод isPrototypeOf() проверяет является ли объект animal прототипом для dog и возвращает 
true или false.*/

// console.log(dog.hasOwnProperty("name")) // true
// console.log(dog.name) // 'Mango'

// console.log(dog.hasOwnProperty("legs")) // false
// console.log(dog.legs) // 4

/*Обращение dog.name работает очевидным образом - возвращает собственное свойство name объекта dog. 
При обращении к dog.legs интерпретатор ищет свойство legs в объекте dog, не находит и продолжает поиск 
в объекте по ссылке из dog.__proto__, то есть, в данном случае, в объекте animal - его прототипе.
 То есть прототип - это резервное хранилище свойств и методов объекта, автоматически используемое 
при их поиске. У объекта, который выступает прототипом может также быть свой прототип, у того свой, и так далее.
 Поиск свойства выполняется до первого совпадения. Интерпретатор ищет свойство по имени в объекте, если не находит, 
то обращается к свойству __proto__, т. е. переходит по ссылке к объекту-прототипу, а затем и прототипу прототипа. 
Если интерпретатор доберется до конца цепочки и не найдет свойства с таким именем, то вернёт undefined.
*/

/*ИНТЕРЕСНО
В спецификации свойство __proto__ обозначено как [[Prototype]]. Двойные квадратные скобки здесь важны, они 
указывают на то, что это внутреннее, служебное свойство.
*/


 //============ Метод hasOwnProperty() ================

 /*После того как мы узнали о том, как происходит поиск свойств объекта, должно стать понятно, почему цикл for...in
 не делает различия между свойствами объекта и его прототипа.
 */

// const animal = {
//    eats: true,
// }
// const dog = Object.create(animal)
// dog.barks = true
 
// for (const key in dog) {
//   console.log(key) // barks, eats
// }

/*Именно поэтому мы используем метод obj.hasOwnProperty(prop), который возвращает true, если свойство 
prop принадлежит самому объекту obj, а не его прототипу, иначе false.
*/

// const animal = {
//   eats: true,
// }
// const dog = Object.create(animal)
// dog.barks = true

// for (const key in dog) {
//   if (!dog.hasOwnProperty(key)) continue

//   console.log(key) // barks
// }

/*Метод Object.keys(obj) вернет массив только собственных ключей объекта obj, поэтому на практике 
используют именно его, а не for...in.
*/

// const animal = {
//   eats: true,
// };
// const dog = Object.create(animal);
// dog.barks = true;

// const dogKeys = Object.keys(dog);

// console.log(dogKeys); // ['barks']



//================= EXAMPLE ================
//==================== 1 ===================

/*Измени код так, чтобы объект parent стал прототипом для объекта в переменной сhild.
*/

// const parent = {
//   name: "Stacey",
//   surname: "Moore",
//   age: 54,
//   heritage: "Irish",
// }

// const child = Object.create(parent)

// child.name = "Jason"
// child.age = 27

// console.log(child)

//==================== 2 ===================

/*Измени код, построив цепочку прототипов так, чтобы объект ancestor был прототипом 
для parent, а тот в свою очередь был прототипом для child.
*/

// const ancestor = {
//   name: "Paul",
//   age: 83,
//   surname: "Dawson",
//   heritage: "Irish",
// };
// // Change code below this line

// const parent = Object.create(ancestor);
// parent.name = "Stacey";
// parent.surname = "Moore";
// parent.age = 54;

// const child = Object.create(parent);
// child.name = "Jason";
// child.age = 27;

// console.log(parent)
// console.log(child)


//=================== Классы ===================

/*Синтаксис литерала объекта позволяет создать один объект. Но часто нужно создать много однотипных объектов 
с одинаковым набором свойств, но разными значениями и методами для взаимодействия с ними. Всё это нужно 
сделать динамичекски, во время выполнения программы. Для этого используют классы - специальный синтаксис 
объявления функции для создания объектов.
*/

//=================== Объявление класса ===================

/*Объявление класса начинается с ключевого слова class, после которого идёт имя класса и фигурные 
скобки - его тело. Классы принято называть с большой буквы, а в самом названии отражать тип создаваемого 
объекта (существительное).
*/

// class User {
//   // Тело класса
// }

// const mango = new User()
// console.log(mango) // User {}

// const poly = new User()
// console.log(poly) // User {}

/*Результат вызова new User() это объект, который называется экземпляр класса, потому что содержит данные и 
поведение, описываемые классом.
*/

/*ИНТЕРЕСНО
Как строить класс, зависит от того, что вам нужно. В нашем случае, класс представляет собой пользователя, 
поэтому мы добавим туда поля для имени и почты.
*/


//=================== Конструктор класса ===================

/*Для инициализации экземпляра в классе есть метод constructor. Если он не объявлен, создаётся конструктор 
по умолчанию - пустая функция, которая не изменяет экземпляр.
*/

// class User {
//   // Синтаксис объявления метода класса
//   constructor(name, email) {
//     // Инициализация свойств экземпляра
//     this.name = name
//     this.email = email
//   }
// }

// const mango = new User("Манго", "mango@mail.com")
// console.log(mango) // { name: 'Манго', email: 'mango@mail.com' }

// const poly = new User("Поли", "poly@mail.com")
// console.log(poly) // { name: 'Поли', email: 'poly@mail.com' }

/*Вызов класса с оператором new приводит к созданию нового объекта и вызову конструктора в контексте этого объекта. 
 То есть this внутри конструктора будет ссылаться на новосозданный объект. Это позволяет добавлять каждому объекту 
свойства с одинаковыми именами, но разными значениями.
 Свойства name и email называются публичные свойства, потому что они будут собственными свойствами объекта-экземпляра 
и к ним можно будет получить доступ обратившись через точку.*/

//============== EXAMPLE ================
//================= 1 ===================

/*Добавь классу Car метод constructor который принимает три параметра:
  • brand - марка автомобиля.
  • model - модель автомобиля.
  • price - цена автомобиля.
Класс Car должен создавать объект с одноимёнными свойствами brand, model и price, значениями которых должны быть 
переданные аргументы во время её вызова с оператором new.
*/

// class Car {
//   constructor(brand, model, price) {
//     this.brand = brand
//     this.model = model
//     this.price = price
//   }
// }

// const audi = new Car("Audi", "Q3", 36000)
// console.log(audi)

// const bmw = new Car("BMW", "X5", 58900)
// console.log(bmw)

// const nissan = new Car("Nissan","Murano", 31700)
// console.log(nissan)


//=================== Объект параметров ===================

/*Класс может принимать большое количество входных данных для свойств будущего объекта. Поэтому к ним также можно 
применить паттерн «Объект параметров, передавая один объект с логично именованными свойствами, вместо несвязанного 
набора аргументов.
*/

// class User {
//   // Деструктуризируем объект
//   constructor({ name, email }) {
//     this.name = name;
//     this.email = email;
//   }
// }

// const mango = new User({
//   name: "Манго",
//   email: "mango@mail.com",
// });
// console.log(mango); // { name: "Манго", email: "mango@mail.com" }

// const poly = new User({
//   name: "Поли",
//   email: "poly@mail.com",
// });
// console.log(poly); // { name: "Поли", email: "poly@mail.com" }

//============== EXAMPLE ================
//================= 1 ===================

/*Выполни рефакторинг класса Car так, чтобы он принимал один параметр - объект со свойсвами brand, model и price. 
Деструктуризируй объект в сигнатуре (подписи) конструктора.
*/

//  class Car {
//    constructor({ brand, model, price }) {
//     this.brand = brand
//     this.model = model
//     this.price = price
//   }
// }

// const audi = new Car({
//   brand: "Audi",
//   model: "Q3",
//   price: 36000,
// })
// console.log(audi)

// const bmw = new Car({
//   brand: "BMW",
//   model: "X5",
//   price: 58900,
// })
// console.log(bmw)

// const nissan = new Car({
//   brand: "Nissan",
//   model: "Murano",
//   price: 31700,
// })
// console.log(nissan)


//=================== Методы класса ===================

/*Для работы со свойствами будущего экземпляра используются методы класса - функции которые будут доступны 
экземпляру в его прототипе.
*/

class User {
  constructor({ name, email }) {
    this.name = name;
    this.email = email;
  }

  // Метод getEmail
  getEmail() {
    return this.email;
  }

  // Метод changeEmail
  changeEmail(newEmail) {
    this.email = newEmail;
  }
}

const mango = new User({
  name: 'Mango',
  email: '1234@gmail.com',
})

console.log(mango)


//============== EXAMPLE ================
//================= 1 ===================

/*Добавь классу Car два метода.
  • getPrice() - возвращает значение свойства price из объекта который его будет вызывать.
  • changePrice(newPrice) - обновляет значение свойства price у объекта который его будет вызывать на newPrice.
*/

class Car {
  constructor({ brand, model, price }) {
    this.brand = brand;
    this.model = model;
    this.price = price;
  }

  getPrice() {
    return this.price
  }

  changePrice(newPrice) {
    this.price = newPrice
  }
}

 const nissan = new Car({
  brand: "Nissan",
  model: "Murano",
  price: 31700,
})
console.log(Car.prototype.hasOwnProperty('getPrice'))


//================= 2 ===================

/*Напиши класс Storage, который будет создавать объекты для управления складом товаров. 
Класс ожидает только один аргумент - начальный массив товаров, который записывается на 
создаваемый объект в свойство items.
 Объяви следующие методы класса:
  • getItems() - возвращает массив текущих товаров в свойстве items объекта который 
вызывает этот метод.
  • addItem(newItem) - принимает новый товар newItem и добавляет его в массив товаров 
в свойстве items объекта который вызывает этот метод.
  • removeItem(itemToRemove) - принимает товар itemToRemove и удаляет его из массива 
товаров в свойстве items объекта который вызывает этот метод.
Под комментарием мы добавили инициализацию экземпляра и вызовы методов в той последовательности, 
в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.
*/

class Storage {
  constructor(items) {
    this.items = items
  }
  
  getItems() {
    return this.items
  }

  addItem(newItem) {
    this.items.push(newItem)
  }

  removeItem(itemToRemove) {
    this.items = this.items.filter(item => item !== itemToRemove)
  }
}

const storage = new Storage(["Nanitoids", "Prolonger", "Antigravitator"])
console.log(storage.getItems()) // ["Nanitoids", "Prolonger", "Antigravitator"]

storage.addItem("Droid")
console.log(storage.getItems()) // ["Nanitoids", "Prolonger", "Antigravitator", "Droid"]

storage.removeItem("Prolonger");
console.log(storage.getItems()); // ["Nanitoids", "Antigravitator", "Droid"]

const courseTopic = 'JavaScript essentials'


//================= 3 ===================

/*Напиши класс StringBuilder, который принимает один параметр initialValue - произвольную 
строку, которая записывается на создаваемый объект в свойство value.
 Объяви следующие методы класса:
  • getValue() - возвращает текущее значение свойства value.
  • padEnd(str) - получает парметр str (строку) и добавляет её в конец значения свойства 
  value объекта который вызывает этот метод.
  • padStart(str) - получает парметр str (строку) и добавляет её в начало значения свойства 
  value объекта который вызывает этот метод.
  • padBoth(str) - получает парметр str (строку) и добавляет её в начало и в конец значения 
  свойства value объекта который вызывает этот метод.
 Под комментарием мы добавили инициализацию экземпляра и вызовы методов в той последовательности, 
 в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.
 */

class StringBuilder {
  constructor(initialValue) {
    this.value = initialValue
  }

  getValue() {
     return this.value
  }

  padEnd(str) {
    this.value += str
  }

  padStart(str) {
    this.value = str + this.value
  }

  padBoth(str) {
    this.value = str + this.value + str
  }
  
}

const builder = new StringBuilder(".");
console.log(builder.getValue()); // "."

builder.padStart("^");
console.log(builder.getValue()); // "^."

builder.padEnd("^");
console.log(builder.getValue()); // "^.^"

builder.padBoth("=");
console.log(builder.getValue()); // "=^.^="